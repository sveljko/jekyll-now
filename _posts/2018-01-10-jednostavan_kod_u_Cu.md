---
layout: post
title: Писање једноставног кода у Ц-у
lang: sr
---

То што програмирате у Ц-у, не значи да морате да пише лош/сложен/дугачак
код. Ц није непријатељ, јер лош код може да се пише у _било ком_ језику
а добар/једноставан/кратак код _може_ да се пише и у Ц-у. Чак и за
рад са нискама - стринговима.

Угред, "ниска" није најсрећнији превод за стринг, али, још је једино
прихватљива "струна", али ниска се ређе користи у обичном говору, па
је мања шанса да се погрешно тумачење (и изворни превод "Програмског
Језика Ц" користи израз "ниска")

## Сви кажу да је Ц катастрофа за рад са нискама

Оно што се обично мисли је да "има много да се ради" да би се
обрађивале ниске у Ц-у, јер не постоји права апстракција. Постоји само
конвенција, подржана од стране дословних ниски (енг. _string literal_)
и стандардне библиотеке, да је низ знакова који се завршава НУЛ знаком
(`'\0'`) управо ниска

Ово јесте проблем, али, врло често, није потребно "прасити се" у
обради ниски. Само треба бити пажљив.

## Да видимо тај лош код.

Следи функција написани у комерцијалним условима, од стране умерено
искусног и способног програмера који зна Ц. То је добар пример како
"страшне" ствари људе праве у Ц-у, без икаквог разлога.

```c
#define EXPECTED_STRING "Whatev"

int read_expected_string(int stream)
{
    char line[1024];
    size_t expected_len = strlen(EXPECTED_STRING);
    
    int count = read(stream, line, sizeof line);
    int line_length = (count < sizeof(line)) ? count : (sizeof(line) - 1); 

    if(line_length < (version_tag_len)) 
    { 
        return FAILURE; 
    } 

    line[line_length] = '\0'; 
    line[version_tag_len] = '\0'; 

    if(!strcmp(line, EXPECTED_STRING)) 
    { 
        return SUCCESS; 
    } 
    return FAILURE; 
}
```

Пробајте да схватите шта овај код покушава да уради. Немојте да читате
даље док не откријете о чему је реч, или вам се просто смучи од
гледања.

Постоји више проблема у овом коду. Неке би решио добар оптимизијући
преводилац (`strlen()` рачуна дужину дословне ниске, наместо да се
употреби `sizeof`). Неки "генијални" преводилац би чак могао да
закључи да нема потребе за `line[line_length] = '\0'`, јер
`version_tag_len <= line_length`, па наредни ред ничему не служи,
ниска је већ окраћена више него што ће то тај наредни ред да постигне.

Назив функције такође није сјајан. Како стоји, човек би помислио да ће
`stream` бити читан све док не добијемо `EXPECTED_STRING`. Што управо
_није_ случај.

Чак и да све ово наведено средимо ми или наш генијални преводилац,
ово је и даље преко сваке мере сложено.

Овај код, у ствари, само жели да прочита једну ниску - ред из неког
"тока" (небитно шта је тај ток - датотека, утичница, цев...) и
упореди то са очекиваном ниском. Ништа више.

## У вашем омиљеном вишем програмском језику

Ако имате одговарајућу библиотеку за "ток", требало би да можете да
напишете (ово је Руби, али слично је могуће у многим језицима):

```ruby
def expect_string(stream)
    stream.read().start_with?(EXPECTED_STRING)
end
```

Ово очигедно не обрађује грешке, већ се ослања на изузетке, нити
ограничава дужину прочитаног - мада, за ту сврху, можда постоји
`read(max_bytes)`.

Суштина је да је о овом коду врло лако размишљати и доносити
закључке. Прилично је очигледно шта (жели да) ради.

## Назад у Ц

Хајде да пробамо да схватимо "откуд сав овај код".
Аутор је био у стању свести да, у Ц-у, мора да се води рачуна
о нискама "ручно". Што и јесте тачно, али, у ствари није.

Дакле, мора да се води рачуна ручно, али не мора "на сваком
кораку".

На вишем нивоу апстракције, овај код ради следеће:

    прочита (ред) из тока
	израчуна позицију за НУЛ знак (да направи ниску реда)
	ако је прочитано прекратко, враћа НЕУСПЕХ
	ставља НУЛ знак у прочитан ред да направи "праву ниску"
	ако је ниска реда једнака очекиваној враћа УСПЕХ
	иначе, враћа НЕУСПЕХ

Све је то лепо, али, не мора све то да ради. Нема потребе за
рачунањем, јер нема потребе да за "правом" АСЦИИЗ ниском.  Поређење са
`strcmp()` стаје код првог НУЛ знака и _неће_ бити проверавано да ли и
друга ниска има НУЛ знак на том месту.

Овај код је лош из још једног разлога. Не обрађује грешке изричито,
већ ту обраду "крије" иза "ако је прочитано прекратко". Наиме,
`read()` враћа `-1` у случају грешке, што је, свакако, прекратко.

Тако "паметан" код је лош, јер да би сте знали да се користи ова
претпоставка, морате да закључујете користећи "окружење".  Односно,
није могуће закључивати о овом коду гледајући само овај код.

Посебно, у случају неких промена, рецимо, у начину рада `read()`, или
клонирању овог кода за употребу са неком функцијом сродном `read()`,
али која ипак ради мало другачије, претпоставке ће да се промене, и
овај код ће нагло да заглупи.

Добро, ево шта можемо да добијемо на основу досадашњих закључака:

```c
int expect_string(int stream)
{
    char line[1024];
    int count = read(stream, line, sizeof line / sizeof line[0]);

    if (count < 0) {
        return FAILURE;
    }
    
    if (0 == strcmp(EXPECTED_STRING, line)) {
        return SUCCESS;
    }
    else {
        return FAILURE;
    }
}
```

Сад се јасно види да нас није брига колико је дугачка
`EXPECTED_STRING`, па просто можемо да је проследимо као параметер,
чинећи саму функцију општијом.  Уз пар ситних Ц трикова, добијамо
знатно краће:

```c
int expect_string(int stream, char const* expected)
{
    char l[1024];

    return ((read(stream, l, sizeof l / sizeof l[0]) > 0) && 
	    (0 == strcmp(expected, l))) ? 
		SUCCESS : FAILURE;
}
```

Овде је прелом реда прављен на 60 знакова ради "преносиве читљивости".
Али `return` може да стане у један ред, који може да буде краћи ако
"злоупотребимо" нека сазнања о овом коду:

* Максимална дужина реда је већ константа која може да се употреби
* `SUCCESS == 0` и `FAILURE == -1`, како је и обичај у Ц-у

```c
int expect_string(int sm, char const* ex)
{
    char l[MAX_LINE_LEN];

    return ((read(sm, l, MAX_LINE_LEN) > 0) && (0 == strcmp(ex, l))) - 1;
}
```

Ред је сад краћи од 80 знакова, што је било у реду чак и у доба ДОС-а.

Ово су и даље два реда кода. Од тога може да се побегне ако смо у
једно-нитном окружењу, па можемо да употребимо постојећи `static char
l[]`, или ако смо спремни да жтрвујемо лакоћу употребе:

```c
int expect_string(int sm, char const* ex, char* ln, size_t max_len)
{
    return ((read(sm, ln, max_len) > 0) && (0 == strcmp(ex, ln))) - 1;
}
```

Сад корисник (онај ко позива) мора да заузме ниску за радни-помоћни
низ (ред) и да проследи димензију "заузетости", што је мало
непријатно.

Али, иако је овај "једини прави ред" ипак нешто дужи и опширнији од
сличног у вишем пргорамском језику, он обрађује грешке изричито (без
изуетака, који су скупи на _много_ начина) и _не_ заузима икакву
меморију (са хрпе), што значи да је значајно бржи.

## Ц++ трик са упућењем на низ и шаблоном

У Ц++ би било очеивано да се користи `std::string` и IOStreams, али,
сасвим је у реду да се остане "ниско", али ипак користе неке олакшице,
попут ове која олакшава употребу кориснику који има статички заузету
ниску:

```c++
template <int N> inline
int expect_string(int sm, char const* ex, char (ln&)[N]) {
    return ((read(sm, ln, N) > 0) && (0 == strcmp(ex, ln))) - 1;
}
```

## Наравоученије

Ако се пажљвио размисли шта је оно што хоћемо да постигнемо у неком Ц
коду, што је нашем случају била обрада неких ниски, могуће је написати
код који ради _само оно што мора_. Такав код је обично сличне
сложености и опширности као код који постиже исто у вишем програмском
језику, али је, ако је исправно написан, бржи, користи мање ресураса и
изричито обрађује грешке.
